### B树和B+树的区别，为什么Mysql使用B+树

**B树的特点：**

1. 节点排序
2. 一个节点可以存多个元素，多个元素也排序了

**B+树的特点：**

1. 拥有B树的特点
2. 叶子节点之间有指针
3. 非叶子节点上的元素在叶子节点上都冗余了，也就是叶子节点中存储了所有的元素，并且排好顺序

Mysql索引使用的是B+树，因为索引是用来加快查询的，而B+树通过对数据进行排序所以是可以提高查询速度的，然后通过一个元素可以存储多个元素，从而可以使得B+树的高度不会太高，在Mysql中一个Innodb页就是一个B+树节点，一个Innodb页默认16kb，，所以一般情况下一颗两层的B+树可以存2000万行左右的数据，然后通过利用B+树叶子节点存储了所有的数据并且进行了排序，并且叶子节点之间有指针，可以很好的支持全表扫描，范围查找等SQL语句。

### MySQL锁有哪些？什么是间隙锁？

从锁的粒度来区分：

1. 行锁：加锁粒度小，但是加锁资源开销比较大。InnDB支持。
   + 共享锁：读锁。多个事务可以对同一个数据共享一把锁。持有锁的事务都可以访问数据，但是只能读不能修改。select xxx LOCK IN SHARE MODE。
   + 排他锁：写锁。只有一个事务能够获得排他锁，其他事务都不能获取该行的锁。InnoDB会对update\delete\insert语句自动添加排他锁。SELECT xxx FOR UPDATE。
   + 自增锁：通常是针对MySQL当中的自增字段。如果有事务回滚这种情况，数据会回滚，但是自增序列不会回滚。
2. 表锁：加锁粒度大，加锁资源开销比较小。MyISAM和InnoDB都支持。
   + 表共享读锁
   + 表排他写锁
   + 意向锁：是InnoDB自动添加的一种锁，不需要用户干预。
3. 全局锁：Flush tables with read lock。加锁之后整个数据库实例都处于只读状态。所有数据变更操作都会被挂起。一般用于全库备份的时候。

常见的锁算法：

user：user_id（1，4，9） update user set xxx where user_id = 5；REPEATABLE READ 间隙锁锁住（5，9）

1. 记录锁：锁一条具体的数据
2. 间隙锁：RR隔离级别下，会加间隙锁。锁一定的范围，而不锁具体的记录。是为了防止产生幻读。(-∞,1)(1,4)(4,9)(9,+∞)
3. Next-key：间隙锁+右记录锁.(-∞,1](1,4](4,9](9,+∞)

### MySQL慢查询该如何优化

1. 检查是否走了索引，如果没有则优化SQL利用索引。
2. 检查所利用的索引，是否是最优索引。
3. 检查所查字段是否都是必须的，是否查询了过多字段，查出了多余数据。
4. 检查表中数据是否过多，是否应该进行分表分库。
5. 检查数据库实例所在机器的性能配置，是否太低，是否可以适当增加资源。

### 索引的基本原理

索引用来快速的寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。

索引的原理：就是把无序的数据变成有序的查询。

1. 把创建了索引的列的内容进行排序。
2. 把排序结果生成倒排表。
3. 在倒排表内容上拼上数据地址链。
4. 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据。